
snippet v
	${1} := ${2}

snippet vr
	var ${1:t} ${2:string}

snippet var
	var ${1} ${2} = ${3}

snippet vars
	var (
		${1} ${2} = ${3}
	)

snippet ap
	append(${1:slice}, ${2:value})

snippet ch
	chan ${1:int}

snippet co
	const (
		${1:NAME1} = iota
		${2:NAME2}
	)

snippet im
	import (
		"${1:package}"
	)

snippet in
	interface{}

snippet inf
	interface ${1:name} {
		${2:/* methods */}
	}

snippet if
	if ${1:/* condition */} {
		${2}
	}

snippet el
	else {
		${1}
	}

snippet ir
	if err != nil {
		${1}
	}

snippet ie
	if ${1:/* condition */} {
		${2}
	} else {
		${3}
	}

snippet fo
	for ${1:i} := 0; $1 < ${2:count}; $1${3:+=1} {
		${3}
	}

snippet df
	defer ${1:func}()

snippet dfr
	defer func() {
		if err := recover(); err != nil {
			${1}
		}
	}()

snippet fr
	for ${1:k}, ${2:v} := range ${3} {
		${4}
	}

snippet fn
	func ${1:funcName}(${2}) ${3:error} {
		${4}
	}


snippet fm
	func (self ${1:type}) ${2:funcName}(${3}) ${4:error} {
		${5}
	}

snippet mk
	make(${1:[]atype}, ${2:0})

snippet map
	map[${1:keyType}]${2:valType}

snippet main
	func main() {
		${1}
	}


snippet nw
	new(${1:type})

snippet pn
	panic("${1:msg}")

snippet logp
	log.Println("${1}")

snippet logf
	log.Printf("%${1:s}", ${2:var})

snippet pr
	fmt.Printf("%${1:s}\n", ${2:var})

snippet prn
	fmt.Println(${1:var})

snippet sp
	fmt.Sprintf("%${1:s}", ${2:var})

snippet sl
	select {
	case ${1:v1} := <-${2:chan1}
		${3}
	case ${4:v2} := <-${5:chan2}
		${6}
	default:
		${7}
	}


snippet tst
	type ${1:name} struct {
		${2}
	}

snippet sw
	switch ${1:var} {
	case ${2:value1}:
		${3}
	case ${4:value2}:
		${5}
	default:
		${6}
	}

snippet cs
	case ${1:value}:
		${2}

snippet gof
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${4})


#
# Testing
#

snippet Tfn
	func Test${1:name  }(t *testing.T) {
		${2}
	}
snippet t.E
	t.Error("\nExp", ${1:this}, "\nGot", ${2:that})
